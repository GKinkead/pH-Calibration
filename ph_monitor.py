"""Continuous pH monitoring script for MicroPython on the Raspberry Pi Pico W.

The script reads calibration data generated by ``calibrate_ph_sensor.py`` from
``ph_calibration.json`` (stored on the device filesystem) and prints a pH
measurement once per hour. Use Thonny to deploy this file to the Pico W and run
it after calibrating the probe.
"""

import machine
import ujson
import utime

# ---- User configuration ------------------------------------------------------
ADC_PIN = 26  # GP26 (ADC0) on the Pico W.
CALIBRATION_FILE = "ph_calibration.json"

# Set these to numeric values only if you prefer not to load the JSON file.
# When both are ``None``, the script loads calibration from CALIBRATION_FILE.
MANUAL_SLOPE = None
MANUAL_INTERCEPT = None

# Number of raw ADC samples used to calculate each averaged voltage reading.
SAMPLES_PER_READING = 20
# Delay (in milliseconds) between raw ADC samples during averaging.
SAMPLE_DELAY_MS = 50
# Duration (in seconds) to gather averaged voltage readings before reporting pH.
MEASUREMENT_WINDOW_S = 10
# Interval (in seconds) between reported pH readings.
REPORT_INTERVAL_S = 60 * 60  # One hour.

_adc = machine.ADC(ADC_PIN)
_CONVERSION_FACTOR = 3.3 / 65535


def _read_averaged_voltage(samples=SAMPLES_PER_READING, delay_ms=SAMPLE_DELAY_MS):
    total = 0
    for _ in range(samples):
        total += _adc.read_u16()
        utime.sleep_ms(delay_ms)
    return (total / samples) * _CONVERSION_FACTOR


def _collect_voltage(window_s=MEASUREMENT_WINDOW_S):
    deadline = utime.ticks_add(utime.ticks_ms(), int(window_s * 1000))
    voltages = []
    while utime.ticks_diff(deadline, utime.ticks_ms()) > 0:
        voltages.append(_read_averaged_voltage())
    average_voltage = sum(voltages) / len(voltages)
    variance = sum((v - average_voltage) ** 2 for v in voltages) / len(voltages)
    stdev = variance ** 0.5
    return average_voltage, stdev


def _load_calibration():
    if MANUAL_SLOPE is not None and MANUAL_INTERCEPT is not None:
        return MANUAL_SLOPE, MANUAL_INTERCEPT

    try:
        with open(CALIBRATION_FILE, "r") as file:
            data = ujson.load(file)
        slope = float(data["slope"])
        intercept = float(data["intercept"])
        print(
            "Loaded calibration from {} (slope={:.6f}, intercept={:.6f}).".format(
                CALIBRATION_FILE, slope, intercept
            )
        )
        return slope, intercept
    except (OSError, ValueError, KeyError) as exc:
        raise RuntimeError(
            "Calibration data not available. Run calibrate_ph_sensor.py or set"
            " MANUAL_SLOPE and MANUAL_INTERCEPT."
        ) from exc


def _format_timestamp(epoch_seconds):
    try:
        year, month, mday, hour, minute, second, *_ = utime.localtime(epoch_seconds)
        return "{:04d}-{:02d}-{:02d} {:02d}:{:02d}:{:02d}".format(
            year, month, mday, hour, minute, second
        )
    except (TypeError, ValueError):
        return "{}".format(epoch_seconds)


def _print_header():
    print("\nStarting hourly pH monitoring")
    print("--------------------------------")
    print(
        "Ensure the probe stays immersed in the solution and rinse/soak per"
        " the manufacturer's recommendations to maintain accuracy."
    )
    print("Timestamps use the board's RTC. Configure Wi-Fi/NTP separately if needed.")


def main():
    slope, intercept = _load_calibration()
    _print_header()

    while True:
        start_ms = utime.ticks_ms()
        voltage, stdev = _collect_voltage()
        ph_value = slope * voltage + intercept

        timestamp = _format_timestamp(utime.time())
        print(
            "[{timestamp}] pH={ph:.3f} (avg voltage={voltage:.4f} V, std={std:.2f} mV)".format(
                timestamp=timestamp, ph=ph_value, voltage=voltage, std=stdev * 1000
            )
        )

        elapsed_s = utime.ticks_diff(utime.ticks_ms(), start_ms) / 1000
        sleep_s = REPORT_INTERVAL_S - elapsed_s
        if sleep_s > 0:
            utime.sleep(int(sleep_s))
            fractional = sleep_s - int(sleep_s)
            if fractional > 0:
                utime.sleep_ms(int(fractional * 1000))


if __name__ == "__main__":
    main()
